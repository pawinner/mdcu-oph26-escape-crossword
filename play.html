<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MDCU OPH 2026 - Escape Room: Crossword Quiz</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@100..900&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="https://cdn-icons-png.flaticon.com/512/3420/3420399.png">
    <style>
        :root {
            --cell: 50px;
            --mrna-color: #f39c12;
            --bg: #383838;
            --font-main: 'Lexend', sans-serif;
        }
        body { font-family: 'Lexend', monospace; background: var(--bg); display: flex; flex-direction: column; align-items: center; padding: 20px; }
        .grid { display: grid; grid-template-columns: 100px repeat(12, var(--cell)) 100px; background: #383838; gap: 1px; border: 2px solid #383838; }
        .cell { width: var(--cell); height: var(--cell); background: white; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 1px solid #ccc; box-sizing: border-box; }
        .cell input { font-family: var(--font-main); width: 100%; height: 100%; border: none; text-align: center; font-size: 1.7rem; font-weight: bold; text-transform: uppercase; outline: none; background: transparent; }
        
        /* Normal state for mRNA row (looks like a normal box) */
        .mrna-row { background: white; }
        .empty { background: transparent; }
        .hint { background: #eeeeee ; color: #df599cf9; font-size: 1.7rem; pointer-events: none; user-select: none; }
        .label { 
            background: #c0392b; 
            color: white;
            font-size: 1.7rem; 
            border: none; 
            transition: background-color 0.35s ease, color 0.35s ease;
        }

        .label.solved-word {
            background: #27ae60;
            color: white;
        }

        
        /* Hidden labels initially */
        .end-cap { 
            opacity: 0; 
            transition: opacity 1s ease;
            background: var(--mrna-color); 
            font-size: 1.1rem; 
            font-weight: bold; 
            color: black; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            text-align: center; 
            padding: 2px; 
        }
        
            /* --- Success Animation --- */
        .solved .mrna-row,
        .solved .mrna-row input,
        .solved .mrna-row.hint { 
            /* Alternates between white and orange 3 times over 1.5s */
            animation: toggleSolved 0.488s step-end 16 forwards; 
        }

        @keyframes toggleSolved {
            0%   { background: var(--mrna-color); color: white; }
            50%  { background: white; color: black; }
            100% { background: var(--mrna-color); color: white; }
}
        

        /* Ensure the side labels only appear after the 3rd toggle is finished */
        .solved .end-cap { 
            opacity: 1; 
            transition: opacity 0.5s ease 5.856s; 
        }

        /* Ensures inputs inside the row also blink their text color */
        .solved .mrna-row,
        .solved .mrna-row .input,
        .solved .mrna-row .hint {
            animation: toggleText 0.488s step-end 16 forwards;
        }

        @keyframes toggleText {
            0% { color: black; }
            50%, 100% { color: white; }
        }

        .controls { margin-top: 20px; display: flex; gap: 20px; align-items: center; }
        #status { font-weight: bold; font-size: 1.2rem; color: #d0d0d0; }
        .btn-reset { padding: 8px 16px; cursor: pointer; background: #444; color: white; border: none; border-radius: 4px; font-family: inherit; }

        #confetti {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            pointer-events: none;
            opacity: 0;
            display: none;
            transition: opacity 1s ease;
            z-index: 9999;
        }
    </style>
</head>
<body>
<img id="confetti" src="assets/images/confetti01.gif" alt="Confetti celebration">


<audio id="successSound" src="assets/sounds/[INSTRUMENTAL] Pitbull - Fireball.mp3" preload="auto"></audio>
<audio id="columnSound" src="https://www.myinstants.com/media/sounds/winner-bell-game-show-sound-effect.mp3" preload="auto"></audio>

<div class="grid" id="grid"></div>

<div class="controls">
    <div id="status">ANALYZING GENETIC SAMPLES...</div>
    <button class="btn-reset" onclick="resetPuzzle()">RESET</button>
    <button id="debugBtn" class="btn-reset" style="background: #27ae60;" onclick="fillDebug()">LEAK</button>
</div>

<script>
    const WORDS = [
        "PHAGOCYTOSIS", "IMMUNOLOGY", "G", "PATHOGEN", 
        "TACHYCARDIA", "U", "U", "HYPERGLYCEMIA", 
        "MACROPHAGE", "PNEUMONIA", "A", "ANTIBODY"
    ];

    const MRNA_INDEX = 5; 
    const OFFSETS = [2, 3, 0, 5, 1, 0, 0, 5, 2, 3, 0, 0];

    const RAW_HINTS = [
        [0,0,'P'], [0,1,'H'], [0,2,'A'], [0,3,'G'], [0,4,'O'], [0,5,'C'], [0,6,'Y'], [0,7,'T'], [0,8,'O'], [0,9,'S'], [0,10,'I'], [0,11,'S'], // Phagocytosis
        [1,0,'I'], [1,4,'N'], [1,6,'L'], [1,8,'G'], // Immunology
        [2,0,'G'],
        [3,0,'P'], [3,3,'H'], [3,7,'N'], // Pathogen
        [4,0,'T'], [4,3,'H'], [4,5,'C'], [4,6,'A'], [4,7,'R'], [4,10,'A'], // Tachycardia
        [5,0,'U'],
        [7,0,'H'], [7,1,'Y'], [7,2,'P'], [7,3,'E'], [7,4,'R'], [7,5,'G'], [7,6,'L'], [7,7,'Y'], [7,8,'C'], [7,9,'E'], [7,10,'M'], [7,11,'I'], [7,12,'A'], // Hyperglycemia
        [6,0,'U'],
        [8,0,'M'], [8,1,'A'], [8,3,'R'], [8,5,'P'], [8,9,'E'], // Macrophage
        [9,0,'P'], [9,1,'N'], [9,6,'N'], [9,8,'A'], // Pneumonia
        [10,0,'A'],
        [11,1,'N'], [11,3,'I'], [11,5,'O'], [11,7,'Y'] // Antibody
    ];

    const CONFETTI_FALLBACK_DURATION = 4280; // ms (used if GIF loop count can't be detected)
    const grid = document.getElementById('grid');

    function buildGrid() {
        grid.innerHTML = "";
        grid.innerHTML += `<div class="empty"></div>`;
        for(let i=1; i<=12; i++) {
            grid.innerHTML += `<div class="cell label" data-col="${i-1}">${i}</div>`;
        }
        grid.innerHTML += `<div class="empty"></div>`;

        for (let r = 0; r < 18; r++) {
            grid.innerHTML += (r === MRNA_INDEX) ? `<div class="end-cap">mRNA 5' end</div>` : `<div class="empty"></div>`;
            for (let c = 0; c < 12; c++) {
                const startRow = MRNA_INDEX - OFFSETS[c];
                const charPos = r - startRow;
                if (charPos >= 0 && charPos < WORDS[c].length) {
                    const isMrna = (r === MRNA_INDEX);
                    const hintFound = RAW_HINTS.find(h => h[0] === c && h[1] === charPos);
                    let cellClass = isMrna ? "cell mrna-row" : "cell";
                    if (hintFound) {
                        // If the hint is on the mRNA row, give it both classes
                        let hintClass = isMrna ? "cell mrna-row hint" : "cell hint";
                        grid.innerHTML += `<div class="${hintClass}">${hintFound[2]}</div>`;
                    } else {
                        grid.innerHTML += `<div class="${cellClass}"><input type="text" maxlength="1" data-word="${c}" data-idx="${charPos}" oninput="handleInput(this)"></div>`;
                    }
                } else {
                    grid.innerHTML += `<div class="empty"></div>`;
                }
            }
            grid.innerHTML += (r === MRNA_INDEX) ? `<div class="end-cap">mRNA 3' end</div>` : `<div class="empty"></div>`;
        }
    }

    let hasPlayed = false;
    const solvedColumns = new Set();
    const SOUND_START_TIME = 31.85; // seconds (change this value to adjust start point)
    const SOUND_PLAY_DURATION = 17; // seconds before fade out starts
    const FADE_OUT_DURATION = 3; // seconds for fade out

    function handleInput(input) {
        // Always re-check puzzle state
        checkPuzzle();

        // Only auto-move if a character was entered
        if (!input.value) return;

        const col = parseInt(input.dataset.word);
        const idx = parseInt(input.dataset.idx);

        let nextIdx = idx + 1;

        // Scan downward until we find the next valid input
        while (true) {
            const next = document.querySelector(
                `input[data-word="${col}"][data-idx="${nextIdx}"]`
            );

            if (next) {
                next.focus();
                next.select();
                return;
            }

            // Stop if we are clearly out of bounds
            if (nextIdx > WORDS[col].length) return;

            nextIdx++;
        }
    }

    function handleArrowNavigation(e) {
        const key = e.key;
        if (!["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(key)) return;

        const current = e.target;
        if (!current.matches('input')) return;

        e.preventDefault();

        const col = parseInt(current.dataset.word);
        const idx = parseInt(current.dataset.idx);

        let dCol = 0;
        let dIdx = 0;

        switch (key) {
            case "ArrowUp":    dIdx = -1; break;
            case "ArrowDown":  dIdx =  1; break;
            case "ArrowLeft":  dCol = -1; break;
            case "ArrowRight": dCol =  1; break;
        }

        let nextCol = col + dCol;
        let nextIdx = idx + dIdx;

        // Keep moving in the same direction until we find an input or go out of bounds
        while (true) {
            const next = document.querySelector(
                `input[data-word="${nextCol}"][data-idx="${nextIdx}"]`
            );

            if (next) {
                next.focus();
                next.select();
                return;
            }

            // Stop if we are clearly outside reasonable bounds
            if (
                nextCol < 0 || nextCol >= WORDS.length ||
                nextIdx < 0 || nextIdx > 30
            ) {
                return;
            }

            nextCol += dCol;
            nextIdx += dIdx;
        }
    }

    function checkPuzzle() {
        checkColumns();
        const inputs = document.querySelectorAll('input');
        let isComplete = true;
        inputs.forEach(inp => {
            if (inp.value.toUpperCase() !== WORDS[inp.dataset.word][inp.dataset.idx]) isComplete = false;
        });

        if (isComplete) {
            document.body.classList.add('solved');
            const confetti = document.getElementById('confetti');

            // Restart GIF animation
            confetti.style.display = 'none';
            confetti.offsetHeight; // force reflow
            confetti.style.display = 'block';
            confetti.style.opacity = '1';

            // Fallback: fade out after fixed time (GIF loop count cannot be reliably detected)
            setTimeout(() => {
                confetti.style.opacity = '0';
                setTimeout(() => {
                    confetti.style.display = 'none';
                }, 700); // match CSS transition
            }, CONFETTI_FALLBACK_DURATION);

            document.getElementById('status').innerText = "SEQUENCE REVEALED: AUG GAU UGC UAA";
            
            // ADD THESE LINES TO PLAY SOUND
            if (!hasPlayed) {
                const audio = document.getElementById('successSound');
                audio.currentTime = SOUND_START_TIME;
                audio.volume = 0.35;
                audio.play();

                // Start fade-out after SOUND_PLAY_DURATION
                setTimeout(() => {
                    const fadeInterval = 50; // ms
                    const fadeSteps = FADE_OUT_DURATION * 1000 / fadeInterval;
                    let step = 0;

                    const fade = setInterval(() => {
                        step++;
                        const startVolume = audio.volume;
                        audio.volume = Math.max(0, startVolume * (1 - step / fadeSteps));

                        if (audio.volume === 0) {
                            audio.pause();
                            clearInterval(fade);
                        }
                    }, fadeInterval);
                }, SOUND_PLAY_DURATION * 1000);

                hasPlayed = true;
            }
        } else {
            document.body.classList.remove('solved');
            const confetti = document.getElementById('confetti');
            confetti.style.opacity = '0';
            confetti.style.display = 'none';
            document.getElementById('status').innerText = "ANALYZING GENETIC SAMPLES...";
            hasPlayed = false; // Reset so sound can play again if they fix a mistake
        }
    }

    function checkColumns() {
        const labels = document.querySelectorAll('.label[data-col]');

        labels.forEach(label => {
            const col = parseInt(label.dataset.col);
            const inputs = document.querySelectorAll(`input[data-word="${col}"]`);

            let correct = true;
            inputs.forEach(inp => {
                if (inp.value.toUpperCase() !== WORDS[col][inp.dataset.idx]) {
                    correct = false;
                }
            });

            if (inputs.length === 0) {
                // Fully pre-filled column â†’ always correct
                label.classList.add('solved-word');

                // Do NOT play sound for prefilled columns
                solvedColumns.add(col);
                return;
            }

            if (correct) {
                label.classList.add('solved-word');

                if (!solvedColumns.has(col)) {
                    solvedColumns.add(col);
                    const sound = document.getElementById('columnSound');
                    sound.currentTime = 0;
                    sound.volume = 0.5;
                    sound.play();
                }
            } else {
                label.classList.remove('solved-word');
                solvedColumns.delete(col);
            }
        });
    }

    function fillDebug() {
        const inputs = document.querySelectorAll('input');
        inputs.forEach(inp => {
            const w = parseInt(inp.dataset.word);
            const i = parseInt(inp.dataset.idx);
            
            // Fill everything EXCEPT the letter 'Y' in 'ANTIBODY' (Word 11, Index 7)
            if (!(w === 11 && i === 6)) {
                inp.value = WORDS[w][i];
            }
        });
        checkPuzzle(); // Refresh the state
    }

    function resetPuzzle() {
        if(confirm("Clear all inputs?")) {
            hasPlayed = false;
            solvedColumns.clear();
            document.body.classList.remove('solved');
            const confetti = document.getElementById('confetti');
            confetti.style.opacity = '0';
            confetti.style.display = 'none';
            document.getElementById('status').innerText = "ANALYZING GENETIC SAMPLES...";
            buildGrid();
            checkColumns();
        }
    }

    buildGrid();
    checkColumns();

    grid.addEventListener('keydown', handleArrowNavigation);
</script>
</body>
</html>